/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => RackVisualizationPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");

// rackml-parser.ts
var RackMLParser = class {
  static parseRackML(rackmlContent) {
    const parser = new DOMParser();
    const doc = parser.parseFromString(rackmlContent, "text/xml");
    const racksElement = doc.documentElement;
    if (racksElement.tagName !== "racks") {
      throw new Error("Root element must be 'racks'");
    }
    const rackSet = {
      base: racksElement.getAttribute("base") || void 0,
      racks: []
    };
    const rackNodes = racksElement.getElementsByTagName("rack");
    for (let i = 0; i < rackNodes.length; i++) {
      const rackNode = rackNodes[i];
      const rack = this.parseRack(rackNode);
      rackSet.racks.push(rack);
    }
    return rackSet;
  }
  static parseRack(rackElement) {
    const rack = {
      name: rackElement.getAttribute("name") || "",
      height: parseInt(rackElement.getAttribute("height") || "42", 10),
      devices: []
    };
    const deviceNodes = rackElement.children;
    for (let i = 0; i < deviceNodes.length; i++) {
      const deviceNode = deviceNodes[i];
      const device = this.parseDevice(deviceNode);
      if (device) {
        rack.devices.push(device);
      }
    }
    return rack;
  }
  static parseDevice(deviceElement) {
    var _a;
    const deviceType = deviceElement.tagName;
    if (deviceType === "gap") {
      return null;
    }
    const device = {
      type: deviceType,
      name: ((_a = deviceElement.textContent) == null ? void 0 : _a.trim()) || "",
      height: parseInt(deviceElement.getAttribute("height") || "1", 10),
      href: deviceElement.getAttribute("href") || void 0,
      color: deviceElement.getAttribute("color") || void 0
    };
    const atAttribute = deviceElement.getAttribute("at");
    if (atAttribute) {
      device.position = parseInt(atAttribute, 10);
    }
    return device;
  }
};

// text-markup-parser.ts
var TextMarkupParser = class {
  constructor(content) {
    this.lines = content.split(/[\n\r]/).map((line) => line.trim()).filter((line) => line.length > 0);
    this.currentLine = 0;
  }
  parse() {
    const rackSet = {
      racks: []
    };
    const rack = this.parseRack();
    rackSet.racks.push(rack);
    return rackSet;
  }
  parseRack() {
    const rack = {
      name: "",
      height: 42,
      devices: []
    };
    this.parseHeader(rack);
    this.parseItems(rack);
    return rack;
  }
  parseHeader(rack) {
    const captionLine = this.getNextLine();
    if (!captionLine.startsWith("caption:")) {
      throw new Error(`Expected 'caption:' at line ${this.currentLine}, got: ${captionLine}`);
    }
    rack.name = captionLine.substring(8).trim();
    const heightLine = this.getNextLine();
    if (!heightLine.startsWith("height:")) {
      throw new Error(`Expected 'height:' at line ${this.currentLine}, got: ${heightLine}`);
    }
    const heightStr = heightLine.substring(7).trim();
    const height = parseInt(heightStr, 10);
    if (isNaN(height)) {
      throw new Error(`Invalid height value: ${heightStr}`);
    }
    rack.height = height;
  }
  parseItems(rack) {
    const itemsLine = this.getNextLine();
    if (!itemsLine.startsWith("items:")) {
      throw new Error(`Expected 'items:' at line ${this.currentLine}, got: ${itemsLine}`);
    }
    while (this.hasMoreLines()) {
      const line = this.peekNextLine();
      if (!line.trimStart().startsWith("-")) {
        break;
      }
      const device = this.parseItemEntry();
      rack.devices.push(device);
    }
  }
  parseItemEntry() {
    let line = this.getNextLine();
    line = line.trimStart();
    if (!line.startsWith("-")) {
      throw new Error(`Expected '-' at beginning of item entry at line ${this.currentLine}`);
    }
    line = line.substring(1).trim();
    const colonIndex = line.indexOf(":");
    if (colonIndex === -1) {
      throw new Error(`Expected ':' in item entry at line ${this.currentLine}`);
    }
    const keyPart = line.substring(0, colonIndex).trim();
    const labelPart = line.substring(colonIndex + 1).trim();
    const device = this.parseKey(keyPart);
    device.name = this.parseLabel(labelPart);
    device.href = this.extractHrefFromLabel(labelPart);
    return device;
  }
  parseKey(keyPart) {
    const device = {
      type: "",
      name: "",
      height: 1
    };
    const heightMatch = keyPart.match(/^(.+?)\[(\d+)\]$/);
    if (heightMatch) {
      keyPart = heightMatch[1].trim();
      device.height = parseInt(heightMatch[2], 10);
    } else {
      device.height = 1;
    }
    const customTypeMatch = keyPart.match(/^([a-zA-Z][a-zA-Z0-9_-]*):([a-zA-Z][a-zA-Z0-9_-]*)$/);
    if (customTypeMatch) {
      device.type = customTypeMatch[2];
    } else {
      if (!/^[a-zA-Z][a-zA-Z0-9_-]*$/.test(keyPart)) {
        throw new Error(`Invalid identifier: ${keyPart}`);
      }
      device.type = keyPart;
    }
    return device;
  }
  parseLabel(labelPart) {
    const linkMatch = labelPart.match(/^\[([^\]]+)\]\(([^)]+)\)$/);
    if (linkMatch) {
      return linkMatch[1];
    }
    return labelPart;
  }
  extractHrefFromLabel(labelPart) {
    const linkMatch = labelPart.match(/^\[([^\]]+)\]\(([^)]+)\)$/);
    if (linkMatch) {
      return linkMatch[2];
    }
    return void 0;
  }
  getNextLine() {
    if (this.currentLine >= this.lines.length) {
      throw new Error("Unexpected end of input");
    }
    return this.lines[this.currentLine++];
  }
  peekNextLine() {
    if (this.currentLine >= this.lines.length) {
      return "";
    }
    return this.lines[this.currentLine];
  }
  hasMoreLines() {
    return this.currentLine < this.lines.length;
  }
};

// color-schemes.ts
var ColorSchemes = class {
  static getColor(deviceType, scheme = "pastel") {
    const colorScheme = this.schemes[scheme];
    if (colorScheme) {
      return colorScheme[deviceType] || colorScheme["_default"];
    }
    return "white";
  }
  static getSchemes() {
    return this.schemes;
  }
};
ColorSchemes.schemes = {
  "default": {
    "_default": "white",
    "blank": "#e2e8f0",
    "cables": "#f6ad55",
    "firewall": "#f56565",
    "patch": "#faf089",
    "pdu": "#38a169",
    "storage": "#4fd1c5",
    "server": "#63b3ed",
    "switch": "#b1dd9e",
    "ups": "#38a169",
    "router": "#0583D2",
    "monitor": "#e2e8f0",
    "keyboard": "#e2e8f0",
    "kvm": "#e2e8f0",
    "tape": "#c7ceea"
  },
  "pastel": {
    "_default": "#f4f4f4",
    "cables": "#ffdac1",
    "firewall": "#ff9aa2",
    "patch": "#ffdac1",
    "pdu": "#b5ead7",
    "storage": "#c7ceea",
    "server": "#c7ceea",
    "switch": "#b1dd9e",
    "tape": "#c7ceea",
    "ups": "#b5ead7",
    "router": "#54c2cc",
    "monitor": "#f4f4f4",
    "keyboard": "#f4f4f4",
    "kvm": "#f4f4f4",
    "blank": "#f4f4f4"
  }
};

// device-symbols.ts
var DeviceSymbols = class {
  static getSymbolPath(deviceType) {
    switch (deviceType) {
      case "router":
        return "M 12 7 l -5 5 l 5 5 m 3 -5 a 1,1 0 1,1 -2,0 a 1,1 0 1,1 2,0 m 5 0 a 1,1 0 1,1 -2,0 a 1,1 0 1,1 2,0 m 5 0 a 1,1 0 1,1 -2,0 a 1,1 0 1,1 2,0 m 1 -5 l 5 5 l -5 5";
      case "cables":
        return "M 12 7 l -5 5 l 5 5 m 3 -5 a 1,1 0 1,1 -2,0 a 1,1 0 1,1 2,0 m 5 0 a 1,1 0 1,1 -2,0 a 1,1 0 1,1 2,0 m 5 0 a 1,1 0 1,1 -2,0 a 1,1 0 1,1 2,0 m 1 -5 l 5 5 l -5 5";
      case "firewall":
        return "M 8 6.5 h 20 v 12 h -20 z m 0 4 h 20 m 0 4 h -20 M 7 7 m 7 0 v 4 m 8 0 v -4 m -4 4 v 4 m -4 0 v 4 m 8 0 v -4";
      case "pdu":
        return "M 17 5 v 7 m 3 -5 a 6 6 240 1 1 -6 0";
      case "storage":
        return "M 7 7 v 15 h 5 v -15 h -5 m 7 0 v 15 h 5 v -15 h -5 m 7 0 v 15 h 5 v -15 h -5";
      case "server":
        return "M 7 5 h 20 v 7 h -20 v -7 m 0 8 h 20 v 7 h -20 v -7 M 25 8 a 2,2 0 1,1 -4,0 a 2,2 0 1,1 4,0 M 25 16 a 2,2 0 1,1 -4,0 a 2,2 0 1,1 4,0";
      case "switch":
        return "M 19 5 h 6 v -2.5 l 4 4 l -4 4 v -2.5 h -6 m -2 1 h -6 v -2.5 l -4 4 l 4 4 v -2.5 h 6 m 2 2 h 6 v -2.5 l 4 4 l -4 4 v -2.5 h -6 m -2 1 h -6 v -2.5 l -4 4 l 4 4 v -2.5 h 6";
      case "ups":
        return "M 15 7 h 6 l -3 5 h 3 l -8 10 l 2 -7 h -3";
      default:
        return "";
    }
  }
  static getPatchPanelPorts() {
    const ports = [];
    const positions = [
      { x: 7, y: 7 },
      { x: 14, y: 7 },
      { x: 21, y: 7 },
      { x: 28, y: 7 },
      { x: 7, y: 14 },
      { x: 14, y: 14 },
      { x: 21, y: 14 },
      { x: 28, y: 14 }
    ];
    for (const pos of positions) {
      ports.push({ x: pos.x, y: pos.y, width: 4, height: 4 });
    }
    return ports;
  }
  static getTapeBackground() {
    return { x: 6, y: 7, width: 24, height: 15 };
  }
  static getTapeDriveCircle1() {
    return { cx: 13, cy: 15, r: 3 };
  }
  static getTapeDriveCircle2() {
    return { cx: 23, cy: 15, r: 3 };
  }
};

// svg-generator.ts
var _SvgGenerator = class {
  generateSvg(rackSet) {
    const maxRackHeight = rackSet.racks.length > 0 ? Math.max(...rackSet.racks.map((r) => r.height)) : _SvgGenerator.DEFAULT_RACK_HEIGHT_UNITS;
    const rackCount = rackSet.racks.length;
    const svgHeight = 2 * _SvgGenerator.DEFAULT_SVG_MARGIN + _SvgGenerator.DEFAULT_RACK_UNIT_POINTS * maxRackHeight;
    let maxLabelLen = 0;
    for (const rack of rackSet.racks) {
      for (const device of rack.devices) {
        if (device.name && device.name.length > maxLabelLen) {
          maxLabelLen = device.name.length;
        }
      }
    }
    const labelWidth = maxLabelLen * 8 + 32;
    const svgWidth = 2 * _SvgGenerator.DEFAULT_SVG_MARGIN + rackCount * _SvgGenerator.DEFAULT_RACK_WIDTH_POINTS + (rackCount - 1) * _SvgGenerator.DEFAULT_RACK_SPACING_POINTS + labelWidth;
    const svg = [];
    svg.push(`<svg baseProfile="full" height="${svgHeight}" version="1.1" width="${svgWidth}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">`);
    svg.push(`<style>
            a text {
                fill: #0066cc;
                text-decoration: underline;
            }
            a:hover text {
                fill: #004499;
                filter: brightness(90%);
            }
        </style>`);
    svg.push(this.generateEmptyPattern());
    let xOffset = _SvgGenerator.DEFAULT_SVG_MARGIN;
    for (const rack of rackSet.racks) {
      svg.push(`<g transform="translate(${xOffset - 50}, 0)">`);
      svg.push(this.generateRackScale(rack.height));
      svg.push("</g>");
      svg.push(`<g transform="translate(${xOffset}, 0)">`);
      svg.push(this.generateRack(rack, rackSet.base));
      svg.push("</g>");
      xOffset += _SvgGenerator.DEFAULT_RACK_WIDTH_POINTS + _SvgGenerator.DEFAULT_RACK_SPACING_POINTS;
    }
    svg.push("</svg>");
    return svg.join("\n");
  }
  generateEmptyPattern() {
    return `<pattern id="pattern-empty" patternUnits="userSpaceOnUse" width="25" height="25">
            <path d="M 0 12.5 L 25 12.5" fill="none" stroke="#ccc" stroke-width="1"/>
        </pattern>`;
  }
  generateRack(rack, baseHref) {
    const rackSvg = [];
    if (rack.name) {
      const nameY = _SvgGenerator.DEFAULT_SVG_MARGIN / 2 + 2;
      rackSvg.push(`<text x="${_SvgGenerator.DEFAULT_RACK_WIDTH_POINTS / 2}" y="${nameY}" text-anchor="middle" dominant-baseline="middle" font-family="sans-serif">${this.xmlEscape(rack.name)}</text>`);
    }
    rackSvg.push(`<rect x="0" y="${_SvgGenerator.DEFAULT_SVG_MARGIN}" width="${_SvgGenerator.DEFAULT_RACK_WIDTH_POINTS}" height="${rack.height * _SvgGenerator.DEFAULT_RACK_UNIT_POINTS}" fill="url(#pattern-empty)" stroke="black"/>`);
    const rackBottomY = rack.height * _SvgGenerator.DEFAULT_RACK_UNIT_POINTS + _SvgGenerator.DEFAULT_SVG_MARGIN;
    let currentPosition = 0;
    const devices = rack.devices;
    for (const device of devices) {
      const at = device.position !== void 0 ? device.position - 1 : currentPosition;
      const deviceY = _SvgGenerator.DEFAULT_SVG_MARGIN + at * _SvgGenerator.DEFAULT_RACK_UNIT_POINTS;
      rackSvg.push(`<g transform="translate(0, ${deviceY})">`);
      rackSvg.push(this.generateDevice(device, baseHref));
      rackSvg.push("</g>");
      currentPosition = at + device.height;
    }
    return rackSvg.join("\n");
  }
  generateDevice(device, baseHref) {
    const deviceHeight = device.height * _SvgGenerator.DEFAULT_RACK_UNIT_POINTS;
    const color = device.color || ColorSchemes.getColor(device.type);
    const deviceSvg = [];
    deviceSvg.push(`<rect x="0" y="0" width="${_SvgGenerator.DEFAULT_RACK_WIDTH_POINTS}" height="${deviceHeight}" fill="${color}" stroke="black"/>`);
    const textY = deviceHeight / 2 + 2;
    deviceSvg.push(`<text x="${_SvgGenerator.DEFAULT_RACK_WIDTH_POINTS / 2}" y="${textY}" text-anchor="middle" dominant-baseline="middle" font-family="sans-serif" font-size="13">${this.xmlEscape(device.type)}</text>`);
    if (device.name) {
      const labelX = _SvgGenerator.DEFAULT_RACK_WIDTH_POINTS + 16;
      const labelY = deviceHeight / 2 + 2;
      let labelText = `<text x="${labelX}" y="${labelY}" text-anchor="start" dominant-baseline="middle" font-family="sans-serif" font-size="13">${this.xmlEscape(device.name)}</text>`;
      if (device.href) {
        const href = baseHref && this.isAbsoluteUrl(baseHref) ? new URL(device.href, baseHref).toString() : device.href;
        labelText = `<a xlink:href="${this.xmlEscape(href)}">${labelText}</a>`;
      }
      deviceSvg.push(labelText);
    }
    this.addDeviceSymbol(deviceSvg, device);
    const deviceContent = deviceSvg.join("\n");
    if (device.href) {
      const href = baseHref && this.isAbsoluteUrl(baseHref) ? new URL(device.href, baseHref).toString() : device.href;
      return `<a href="${this.xmlEscape(href)}">${deviceContent}</a>`;
    }
    return deviceContent;
  }
  addDeviceSymbol(deviceSvg, device) {
    switch (device.type) {
      case "patch":
        const ports = DeviceSymbols.getPatchPanelPorts();
        for (const port of ports) {
          deviceSvg.push(`<rect x="${port.x}" y="${port.y}" width="${port.width}" height="${port.height}" fill="#555" stroke="none"/>`);
        }
        break;
      case "pdu":
        const pduPath = DeviceSymbols.getSymbolPath("pdu");
        deviceSvg.push(`<path d="${pduPath}" stroke="#555" fill="none" stroke-width="2" stroke-linecap="round"/>`);
        break;
      case "storage":
        const storagePath = DeviceSymbols.getSymbolPath("storage");
        deviceSvg.push(`<path d="${storagePath}" stroke="none" fill="#555" fill-rule="evenodd"/>`);
        break;
      case "server":
        const serverPath = DeviceSymbols.getSymbolPath("server");
        deviceSvg.push(`<path d="${serverPath}" stroke="none" fill="#555" fill-rule="evenodd"/>`);
        break;
      case "switch":
        const switchPath = DeviceSymbols.getSymbolPath("switch");
        deviceSvg.push(`<path d="${switchPath}" fill="#555" stroke="none"/>`);
        break;
      case "tape":
        const bg = DeviceSymbols.getTapeBackground();
        deviceSvg.push(`<rect x="${bg.x}" y="${bg.y}" width="${bg.width}" height="${bg.height}" fill="#555" stroke="none"/>`);
        const circle1 = DeviceSymbols.getTapeDriveCircle1();
        const circle2 = DeviceSymbols.getTapeDriveCircle2();
        deviceSvg.push(`<circle cx="${circle1.cx}" cy="${circle1.cy}" r="${circle1.r}" stroke="#ccc" fill="#555" stroke-width="2"/>`);
        deviceSvg.push(`<circle cx="${circle2.cx}" cy="${circle2.cy}" r="${circle2.r}" stroke="#ccc" fill="#555" stroke-width="2"/>`);
        break;
      case "ups":
        const upsPath = DeviceSymbols.getSymbolPath("ups");
        deviceSvg.push(`<path d="${upsPath}" fill="#555" stroke="none"/>`);
        break;
      default:
        const symbolPath = DeviceSymbols.getSymbolPath(device.type);
        if (symbolPath) {
          deviceSvg.push(`<path d="${symbolPath}" fill="none" stroke="#555" stroke-width="2"/>`);
        }
        break;
    }
  }
  // Scale for height units (U) to the left of the rack
  generateRackScale(rackHeight) {
    const sb = [];
    const scaleX = 44;
    const textX = scaleX;
    const lineX1 = scaleX - 14;
    const lineX2 = scaleX + 2;
    for (let u = rackHeight; u >= 1; u--) {
      const y = _SvgGenerator.DEFAULT_SVG_MARGIN + (rackHeight - u) * _SvgGenerator.DEFAULT_RACK_UNIT_POINTS;
      sb.push(`<text x="${textX}" y="${y + _SvgGenerator.DEFAULT_RACK_UNIT_POINTS / 2 + 2}" text-anchor="end" dominant-baseline="middle" font-family="sans-serif" font-size="12">${u}</text>`);
      sb.push(`<line x1="${lineX1}" y1="${y}" x2="${lineX2}" y2="${y}" stroke="black" stroke-width="2"/>`);
    }
    const yBottom = _SvgGenerator.DEFAULT_SVG_MARGIN + rackHeight * _SvgGenerator.DEFAULT_RACK_UNIT_POINTS;
    sb.push(`<line x1="${lineX1}" y1="${yBottom}" x2="${lineX2}" y2="${yBottom}" stroke="black" stroke-width="2"/>`);
    return sb.join("\n");
  }
  xmlEscape(input) {
    return input.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#39;");
  }
  isAbsoluteUrl(url) {
    try {
      new URL(url);
      return true;
    } catch (e) {
      return false;
    }
  }
};
var SvgGenerator = _SvgGenerator;
SvgGenerator.DEFAULT_RACK_HEIGHT_UNITS = 42;
SvgGenerator.DEFAULT_RACK_SPACING_POINTS = 25;
SvgGenerator.DEFAULT_RACK_UNIT_POINTS = 25;
SvgGenerator.DEFAULT_RACK_WIDTH_POINTS = 300;
SvgGenerator.DEFAULT_SVG_MARGIN = 25;

// main.ts
var RackVisualizationPlugin = class extends import_obsidian.Plugin {
  async onload() {
    console.log("Loading Rack Visualization Plugin");
    this.registerMarkdownCodeBlockProcessor("rack-xml", (source, el, ctx) => {
      this.processRackXml(source, el, ctx);
    });
    this.registerMarkdownCodeBlockProcessor("rack-text", (source, el, ctx) => {
      this.processRackText(source, el, ctx);
    });
    this.registerMarkdownCodeBlockProcessor("rackml", (source, el, ctx) => {
      this.processRackXml(source, el, ctx);
    });
    this.registerMarkdownCodeBlockProcessor("rack", (source, el, ctx) => {
      this.processRackText(source, el, ctx);
    });
  }
  onunload() {
    console.log("Unloading Rack Visualization Plugin");
  }
  processRackXml(source, el, ctx) {
    try {
      const rackSet = RackMLParser.parseRackML(source.trim());
      this.convertObsidianLinks(rackSet, ctx);
      const svgGenerator = new SvgGenerator();
      const svgContent = svgGenerator.generateSvg(rackSet);
      this.insertSvg(el, svgContent);
    } catch (error) {
      this.showError(el, `Error parsing RackML XML: ${error.message}`);
    }
  }
  processRackText(source, el, ctx) {
    try {
      const parser = new TextMarkupParser(source.trim());
      const rackSet = parser.parse();
      this.convertObsidianLinks(rackSet, ctx);
      const svgGenerator = new SvgGenerator();
      const svgContent = svgGenerator.generateSvg(rackSet);
      this.insertSvg(el, svgContent);
    } catch (error) {
      this.showError(el, `Error parsing rack text markup: ${error.message}`);
    }
  }
  convertObsidianLinks(rackSet, ctx) {
    for (const rack of rackSet.racks) {
      for (const device of rack.devices) {
        if (device.href) {
          device.href = this.resolveObsidianLink(device.href, ctx);
        }
        if (device.name) {
          const linkMatch = device.name.match(/\[\[([^\]]+)\]\]/);
          if (linkMatch) {
            const linkText = linkMatch[1];
            const resolvedLink = this.resolveObsidianLink(linkText, ctx);
            device.name = device.name.replace(linkMatch[0], linkText);
            device.href = resolvedLink;
          }
        }
      }
    }
  }
  resolveObsidianLink(link, ctx) {
    if (link.startsWith("[[") && link.endsWith("]]")) {
      const noteName = link.slice(2, -2);
      return `obsidian://open?vault=${encodeURIComponent(this.app.vault.getName())}&file=${encodeURIComponent(noteName)}`;
    }
    if (!link.startsWith("http://") && !link.startsWith("https://") && !link.startsWith("obsidian://")) {
      return `obsidian://open?vault=${encodeURIComponent(this.app.vault.getName())}&file=${encodeURIComponent(link)}`;
    }
    return link;
  }
  insertSvg(el, svgContent) {
    el.innerHTML = "";
    const container = document.createElement("div");
    container.className = "rack-visualization-container";
    container.style.textAlign = "center";
    container.style.margin = "1em 0";
    container.innerHTML = svgContent;
    const svg = container.querySelector("svg");
    if (svg) {
      svg.style.maxWidth = "100%";
      svg.style.height = "auto";
    }
    el.appendChild(container);
  }
  showError(el, message) {
    el.innerHTML = "";
    const errorDiv = document.createElement("div");
    errorDiv.className = "rack-visualization-error";
    errorDiv.style.color = "red";
    errorDiv.style.border = "1px solid red";
    errorDiv.style.padding = "1em";
    errorDiv.style.borderRadius = "4px";
    errorDiv.style.backgroundColor = "#ffe6e6";
    errorDiv.textContent = message;
    el.appendChild(errorDiv);
  }
};
