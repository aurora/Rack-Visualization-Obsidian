/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/@aurora/rack-visualization-js/dist/models.js
var require_models = __commonJS({
  "node_modules/@aurora/rack-visualization-js/dist/models.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DeviceType = void 0;
    var DeviceType;
    (function(DeviceType2) {
      DeviceType2["Server"] = "server";
      DeviceType2["Switch"] = "switch";
      DeviceType2["Firewall"] = "firewall";
      DeviceType2["Router"] = "router";
      DeviceType2["Cables"] = "cables";
      DeviceType2["Patch"] = "patch";
      DeviceType2["PDU"] = "pdu";
      DeviceType2["UPS"] = "ups";
      DeviceType2["Storage"] = "storage";
      DeviceType2["Tape"] = "tape";
      DeviceType2["Monitor"] = "monitor";
      DeviceType2["Keyboard"] = "keyboard";
      DeviceType2["KVM"] = "kvm";
      DeviceType2["Blank"] = "blank";
      DeviceType2["Gap"] = "gap";
    })(DeviceType = exports.DeviceType || (exports.DeviceType = {}));
  }
});

// node_modules/@aurora/rack-visualization-js/dist/rackml-parser.js
var require_rackml_parser = __commonJS({
  "node_modules/@aurora/rack-visualization-js/dist/rackml-parser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RackMLParser = void 0;
    var RackMLParser2 = class {
      static parseRackML(rackmlContent) {
        const parser = new DOMParser();
        const doc = parser.parseFromString(rackmlContent, "text/xml");
        const racksElement = doc.documentElement;
        if (racksElement.tagName !== "racks") {
          throw new Error("Root element must be 'racks'");
        }
        const rackSet = {
          racks: []
        };
        const baseAttr = racksElement.getAttribute("base");
        if (baseAttr) {
          rackSet.base = baseAttr;
        }
        const idAttr = racksElement.getAttribute("id");
        if (idAttr) {
          rackSet.id = idAttr;
        }
        const rackNodes = racksElement.getElementsByTagName("rack");
        for (let i = 0; i < rackNodes.length; i++) {
          const rackNode = rackNodes[i];
          if (rackNode) {
            const rack = this.parseRack(rackNode);
            rackSet.racks.push(rack);
          }
        }
        return rackSet;
      }
      static parseRack(rackElement) {
        const rack = {
          name: rackElement.getAttribute("name") || "",
          height: parseInt(rackElement.getAttribute("height") || "42", 10),
          devices: []
        };
        const deviceNodes = rackElement.children;
        for (let i = 0; i < deviceNodes.length; i++) {
          const deviceNode = deviceNodes[i];
          if (deviceNode) {
            const device = this.parseDevice(deviceNode);
            if (device) {
              rack.devices.push(device);
            }
          }
        }
        return rack;
      }
      static parseDevice(deviceElement) {
        var _a;
        const deviceType = deviceElement.tagName;
        if (deviceType === "gap") {
          return null;
        }
        const device = {
          type: deviceType,
          name: ((_a = deviceElement.textContent) === null || _a === void 0 ? void 0 : _a.trim()) || "",
          height: parseInt(deviceElement.getAttribute("height") || "1", 10)
        };
        const hrefAttr = deviceElement.getAttribute("href");
        if (hrefAttr) {
          device.href = hrefAttr;
        }
        const colorAttr = deviceElement.getAttribute("color");
        if (colorAttr) {
          device.color = colorAttr;
        }
        const atAttribute = deviceElement.getAttribute("at");
        if (atAttribute) {
          device.position = parseInt(atAttribute, 10);
        }
        return device;
      }
    };
    exports.RackMLParser = RackMLParser2;
  }
});

// node_modules/@aurora/rack-visualization-js/dist/text-markup-parser.js
var require_text_markup_parser = __commonJS({
  "node_modules/@aurora/rack-visualization-js/dist/text-markup-parser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TextMarkupParser = void 0;
    var TextMarkupParser2 = class {
      constructor(content) {
        this.lines = content.split(/[\n\r]/).map((line) => line.trim()).filter((line) => line.length > 0);
        this.currentLine = 0;
      }
      parse() {
        const rackSet = {
          racks: []
        };
        const rackResult = this.parseRack();
        rackSet.racks.push(rackResult.rack);
        if (rackResult.id) {
          rackSet.id = rackResult.id;
        }
        return rackSet;
      }
      parseRack() {
        const rack = {
          name: "",
          height: 42,
          devices: []
        };
        const headerResult = this.parseHeader(rack);
        this.parseItems(rack);
        const result = { rack };
        if (headerResult.id) {
          result.id = headerResult.id;
        }
        return result;
      }
      parseHeader(rack) {
        let id;
        let nextLine = this.peekNextLine();
        if (nextLine.startsWith("id:")) {
          const idLine = this.getNextLine();
          id = idLine.substring(3).trim();
          if (!id) {
            throw new Error(`ID cannot be empty at line ${this.currentLine}`);
          }
        }
        const captionLine = this.getNextLine();
        if (!captionLine.startsWith("caption:")) {
          throw new Error(`Expected 'caption:' at line ${this.currentLine}, got: ${captionLine}`);
        }
        rack.name = captionLine.substring(8).trim();
        const heightLine = this.getNextLine();
        if (!heightLine.startsWith("height:")) {
          throw new Error(`Expected 'height:' at line ${this.currentLine}, got: ${heightLine}`);
        }
        const heightStr = heightLine.substring(7).trim();
        const height = parseInt(heightStr, 10);
        if (isNaN(height)) {
          throw new Error(`Invalid height value: ${heightStr}`);
        }
        rack.height = height;
        const result = {};
        if (id) {
          result.id = id;
        }
        return result;
      }
      parseItems(rack) {
        const itemsLine = this.getNextLine();
        if (!itemsLine.startsWith("items:")) {
          throw new Error(`Expected 'items:' at line ${this.currentLine}, got: ${itemsLine}`);
        }
        while (this.hasMoreLines()) {
          const line = this.peekNextLine();
          if (!line.trimStart().startsWith("-")) {
            break;
          }
          const device = this.parseItemEntry();
          rack.devices.push(device);
        }
      }
      parseItemEntry() {
        let line = this.getNextLine();
        line = line.trimStart();
        if (!line.startsWith("-")) {
          throw new Error(`Expected '-' at beginning of item entry at line ${this.currentLine}`);
        }
        line = line.substring(1).trim();
        const colonIndex = line.indexOf(":");
        if (colonIndex === -1) {
          throw new Error(`Expected ':' in item entry at line ${this.currentLine}`);
        }
        const keyPart = line.substring(0, colonIndex).trim();
        const labelPart = line.substring(colonIndex + 1).trim();
        const device = this.parseKey(keyPart);
        device.name = this.parseLabel(labelPart);
        const href = this.extractHrefFromLabel(labelPart);
        if (href) {
          device.href = href;
        }
        return device;
      }
      parseKey(keyPart) {
        const device = {
          type: "",
          name: "",
          height: 1
        };
        const heightMatch = keyPart.match(/^(.+?)\[(\d+)\]$/);
        if (heightMatch && heightMatch[1] && heightMatch[2]) {
          keyPart = heightMatch[1].trim();
          device.height = parseInt(heightMatch[2], 10);
        } else {
          device.height = 1;
        }
        const customTypeMatch = keyPart.match(/^([a-zA-Z][a-zA-Z0-9_-]*):([a-zA-Z][a-zA-Z0-9_-]*)$/);
        if (customTypeMatch && customTypeMatch[2]) {
          device.type = customTypeMatch[2];
        } else {
          if (!/^[a-zA-Z][a-zA-Z0-9_-]*$/.test(keyPart)) {
            throw new Error(`Invalid identifier: ${keyPart}`);
          }
          device.type = keyPart;
        }
        return device;
      }
      parseLabel(labelPart) {
        const linkMatch = labelPart.match(/^\[([^\]]+)\]\(([^)]+)\)$/);
        if (linkMatch && linkMatch[1]) {
          return linkMatch[1];
        }
        return labelPart;
      }
      extractHrefFromLabel(labelPart) {
        const linkMatch = labelPart.match(/^\[([^\]]+)\]\(([^)]+)\)$/);
        if (linkMatch) {
          return linkMatch[2];
        }
        return void 0;
      }
      getNextLine() {
        if (this.currentLine >= this.lines.length) {
          throw new Error("Unexpected end of input");
        }
        const line = this.lines[this.currentLine++];
        if (line === void 0) {
          throw new Error("Unexpected undefined line");
        }
        return line;
      }
      peekNextLine() {
        if (this.currentLine >= this.lines.length) {
          return "";
        }
        const line = this.lines[this.currentLine];
        return line || "";
      }
      hasMoreLines() {
        return this.currentLine < this.lines.length;
      }
    };
    exports.TextMarkupParser = TextMarkupParser2;
  }
});

// node_modules/@aurora/rack-visualization-js/dist/color-schemes.js
var require_color_schemes = __commonJS({
  "node_modules/@aurora/rack-visualization-js/dist/color-schemes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ColorSchemes = void 0;
    var ColorSchemes = class {
      static getColor(deviceType, scheme = "pastel") {
        const colorScheme = this.schemes[scheme];
        if (colorScheme) {
          return colorScheme[deviceType] || colorScheme["_default"] || "white";
        }
        return "white";
      }
      static getSchemes() {
        return this.schemes;
      }
    };
    exports.ColorSchemes = ColorSchemes;
    ColorSchemes.schemes = {
      "default": {
        "_default": "white",
        "blank": "#e2e8f0",
        "cables": "#f6ad55",
        "firewall": "#f56565",
        "patch": "#faf089",
        "pdu": "#38a169",
        "storage": "#4fd1c5",
        "server": "#63b3ed",
        "switch": "#b1dd9e",
        "ups": "#38a169",
        "router": "#0583D2",
        "monitor": "#e2e8f0",
        "keyboard": "#e2e8f0",
        "kvm": "#e2e8f0",
        "tape": "#c7ceea"
      },
      "pastel": {
        "_default": "#f4f4f4",
        "cables": "#ffdac1",
        "firewall": "#ff9aa2",
        "patch": "#ffdac1",
        "pdu": "#b5ead7",
        "storage": "#c7ceea",
        "server": "#c7ceea",
        "switch": "#b1dd9e",
        "tape": "#c7ceea",
        "ups": "#b5ead7",
        "router": "#54c2cc",
        "monitor": "#f4f4f4",
        "keyboard": "#f4f4f4",
        "kvm": "#f4f4f4",
        "blank": "#f4f4f4"
      }
    };
  }
});

// node_modules/@aurora/rack-visualization-js/dist/device-symbols.js
var require_device_symbols = __commonJS({
  "node_modules/@aurora/rack-visualization-js/dist/device-symbols.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DeviceSymbols = void 0;
    var DeviceSymbols = class {
      static getSymbolPath(deviceType) {
        switch (deviceType) {
          case "router":
            return "M 12 7 l -5 5 l 5 5 m 3 -5 a 1,1 0 1,1 -2,0 a 1,1 0 1,1 2,0 m 5 0 a 1,1 0 1,1 -2,0 a 1,1 0 1,1 2,0 m 5 0 a 1,1 0 1,1 -2,0 a 1,1 0 1,1 2,0 m 1 -5 l 5 5 l -5 5";
          case "cables":
            return "M 12 7 l -5 5 l 5 5 m 3 -5 a 1,1 0 1,1 -2,0 a 1,1 0 1,1 2,0 m 5 0 a 1,1 0 1,1 -2,0 a 1,1 0 1,1 2,0 m 5 0 a 1,1 0 1,1 -2,0 a 1,1 0 1,1 2,0 m 1 -5 l 5 5 l -5 5";
          case "firewall":
            return "M 8 6.5 h 20 v 12 h -20 z m 0 4 h 20 m 0 4 h -20 M 7 7 m 7 0 v 4 m 8 0 v -4 m -4 4 v 4 m -4 0 v 4 m 8 0 v -4";
          case "pdu":
            return "M 17 5 v 7 m 3 -5 a 6 6 240 1 1 -6 0";
          case "storage":
            return "M 7 7 v 15 h 5 v -15 h -5 m 7 0 v 15 h 5 v -15 h -5 m 7 0 v 15 h 5 v -15 h -5";
          case "server":
            return "M 7 5 h 20 v 7 h -20 v -7 m 0 8 h 20 v 7 h -20 v -7 M 25 8 a 2,2 0 1,1 -4,0 a 2,2 0 1,1 4,0 M 25 16 a 2,2 0 1,1 -4,0 a 2,2 0 1,1 4,0";
          case "switch":
            return "M 19 5 h 6 v -2.5 l 4 4 l -4 4 v -2.5 h -6 m -2 1 h -6 v -2.5 l -4 4 l 4 4 v -2.5 h 6 m 2 2 h 6 v -2.5 l 4 4 l -4 4 v -2.5 h -6 m -2 1 h -6 v -2.5 l -4 4 l 4 4 v -2.5 h 6";
          case "ups":
            return "M 15 7 h 6 l -3 5 h 3 l -8 10 l 2 -7 h -3";
          default:
            return "";
        }
      }
      static getPatchPanelPorts() {
        const ports = [];
        const positions = [
          { x: 7, y: 7 },
          { x: 14, y: 7 },
          { x: 21, y: 7 },
          { x: 28, y: 7 },
          { x: 7, y: 14 },
          { x: 14, y: 14 },
          { x: 21, y: 14 },
          { x: 28, y: 14 }
        ];
        for (const pos of positions) {
          ports.push({ x: pos.x, y: pos.y, width: 4, height: 4 });
        }
        return ports;
      }
      static getTapeBackground() {
        return { x: 6, y: 7, width: 24, height: 15 };
      }
      static getTapeDriveCircle1() {
        return { cx: 13, cy: 15, r: 3 };
      }
      static getTapeDriveCircle2() {
        return { cx: 23, cy: 15, r: 3 };
      }
    };
    exports.DeviceSymbols = DeviceSymbols;
  }
});

// node_modules/@aurora/rack-visualization-js/dist/svg-generator.js
var require_svg_generator = __commonJS({
  "node_modules/@aurora/rack-visualization-js/dist/svg-generator.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SvgGenerator = void 0;
    var color_schemes_1 = require_color_schemes();
    var device_symbols_1 = require_device_symbols();
    var SvgGenerator = class {
      generateSvg(rackSet) {
        const maxRackHeight = rackSet.racks.length > 0 ? Math.max(...rackSet.racks.map((r) => this.calculateActualRackHeight(r))) : SvgGenerator.DEFAULT_RACK_HEIGHT_UNITS;
        const rackCount = rackSet.racks.length;
        const svgHeight = 2 * SvgGenerator.DEFAULT_SVG_MARGIN + SvgGenerator.DEFAULT_RACK_UNIT_POINTS * maxRackHeight;
        let maxLabelLen = 0;
        for (const rack of rackSet.racks) {
          for (const device of rack.devices) {
            if (device.name && device.name.length > maxLabelLen) {
              maxLabelLen = device.name.length;
            }
          }
        }
        const effectiveLabelLen = Math.min(maxLabelLen, 30);
        const labelWidth = effectiveLabelLen * 8 + 32;
        const svgWidth = 2 * SvgGenerator.DEFAULT_SVG_MARGIN + rackCount * SvgGenerator.DEFAULT_RACK_WIDTH_POINTS + (rackCount - 1) * SvgGenerator.DEFAULT_RACK_SPACING_POINTS + labelWidth;
        const svg = [];
        svg.push(`<svg baseProfile="full" viewBox="0 0 ${svgWidth} ${svgHeight}" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" style="max-width: 100%; height: auto;">`);
        svg.push(`<style>
            a text {
                fill: #0066cc;
                text-decoration: underline;
            }
            a:hover text {
                fill: #004499;
                filter: brightness(90%);
            }
            /* Responsive text scaling */
            text {
                font-size: 13px;
            }
            @media (max-width: 768px) {
                text {
                    font-size: 11px;
                }
            }
        </style>`);
        svg.push(this.generateEmptyPattern());
        let xOffset = SvgGenerator.DEFAULT_SVG_MARGIN;
        for (const rack of rackSet.racks) {
          svg.push(`<g transform="translate(${xOffset - 50}, 0)">`);
          svg.push(this.generateRackScale(this.calculateActualRackHeight(rack)));
          svg.push("</g>");
          svg.push(`<g transform="translate(${xOffset}, 0)">`);
          svg.push(this.generateRack(rack, rackSet.base));
          svg.push("</g>");
          xOffset += SvgGenerator.DEFAULT_RACK_WIDTH_POINTS + SvgGenerator.DEFAULT_RACK_SPACING_POINTS;
        }
        svg.push("</svg>");
        return svg.join("\n");
      }
      generateEmptyPattern() {
        return `<pattern id="pattern-empty" patternUnits="userSpaceOnUse" width="25" height="25">
            <path d="M 0 12.5 L 25 12.5" fill="none" stroke="#ccc" stroke-width="1"/>
        </pattern>`;
      }
      generateRack(rack, baseHref) {
        const rackSvg = [];
        const actualRackHeight = this.calculateActualRackHeight(rack);
        if (rack.name) {
          const nameY = SvgGenerator.DEFAULT_SVG_MARGIN / 2 + 2;
          rackSvg.push(`<text x="${SvgGenerator.DEFAULT_RACK_WIDTH_POINTS / 2}" y="${nameY}" text-anchor="middle" dominant-baseline="middle" font-family="sans-serif">${this.xmlEscape(rack.name)}</text>`);
        }
        rackSvg.push(`<rect x="0" y="${SvgGenerator.DEFAULT_SVG_MARGIN}" width="${SvgGenerator.DEFAULT_RACK_WIDTH_POINTS}" height="${actualRackHeight * SvgGenerator.DEFAULT_RACK_UNIT_POINTS}" fill="url(#pattern-empty)" stroke="black"/>`);
        const rackBottomY = actualRackHeight * SvgGenerator.DEFAULT_RACK_UNIT_POINTS + SvgGenerator.DEFAULT_SVG_MARGIN;
        let currentPosition = 0;
        const devices = rack.devices;
        for (const device of devices) {
          const at = device.position !== void 0 ? device.position - 1 : currentPosition;
          const deviceY = SvgGenerator.DEFAULT_SVG_MARGIN + at * SvgGenerator.DEFAULT_RACK_UNIT_POINTS;
          rackSvg.push(`<g transform="translate(0, ${deviceY})">`);
          rackSvg.push(this.generateDevice(device, baseHref));
          rackSvg.push("</g>");
          currentPosition = at + device.height;
        }
        return rackSvg.join("\n");
      }
      generateDevice(device, baseHref) {
        const deviceHeight = device.height * SvgGenerator.DEFAULT_RACK_UNIT_POINTS;
        const color = device.color || color_schemes_1.ColorSchemes.getColor(device.type);
        const deviceSvg = [];
        deviceSvg.push(`<rect x="0" y="0" width="${SvgGenerator.DEFAULT_RACK_WIDTH_POINTS}" height="${deviceHeight}" fill="${color}" stroke="black"/>`);
        const textY = deviceHeight / 2 + 2;
        deviceSvg.push(`<text x="${SvgGenerator.DEFAULT_RACK_WIDTH_POINTS / 2}" y="${textY}" text-anchor="middle" dominant-baseline="middle" font-family="sans-serif" font-size="13">${this.xmlEscape(device.type)}</text>`);
        if (device.name) {
          const labelX = SvgGenerator.DEFAULT_RACK_WIDTH_POINTS + 16;
          const labelY = deviceHeight / 2 + 2;
          const displayName = device.name.length > 30 ? device.name.substring(0, 27) + "..." : device.name;
          let labelText = `<text x="${labelX}" y="${labelY}" text-anchor="start" dominant-baseline="middle" font-family="sans-serif" font-size="13" title="${this.xmlEscape(device.name)}">${this.xmlEscape(displayName)}</text>`;
          deviceSvg.push(labelText);
        }
        this.addDeviceSymbol(deviceSvg, device);
        const deviceContent = deviceSvg.join("\n");
        if (device.href) {
          const href = baseHref && this.isAbsoluteUrl(baseHref) ? new URL(device.href, baseHref).toString() : device.href;
          return `<a href="${this.xmlEscape(href)}">${deviceContent}</a>`;
        }
        return deviceContent;
      }
      addDeviceSymbol(deviceSvg, device) {
        switch (device.type) {
          case "patch":
            const ports = device_symbols_1.DeviceSymbols.getPatchPanelPorts();
            for (const port of ports) {
              deviceSvg.push(`<rect x="${port.x}" y="${port.y}" width="${port.width}" height="${port.height}" fill="#555" stroke="none"/>`);
            }
            break;
          case "pdu":
            const pduPath = device_symbols_1.DeviceSymbols.getSymbolPath("pdu");
            deviceSvg.push(`<path d="${pduPath}" stroke="#555" fill="none" stroke-width="2" stroke-linecap="round"/>`);
            break;
          case "storage":
            const storagePath = device_symbols_1.DeviceSymbols.getSymbolPath("storage");
            deviceSvg.push(`<path d="${storagePath}" stroke="none" fill="#555" fill-rule="evenodd"/>`);
            break;
          case "server":
            const serverPath = device_symbols_1.DeviceSymbols.getSymbolPath("server");
            deviceSvg.push(`<path d="${serverPath}" stroke="none" fill="#555" fill-rule="evenodd"/>`);
            break;
          case "switch":
            const switchPath = device_symbols_1.DeviceSymbols.getSymbolPath("switch");
            deviceSvg.push(`<path d="${switchPath}" fill="#555" stroke="none"/>`);
            break;
          case "tape":
            const bg = device_symbols_1.DeviceSymbols.getTapeBackground();
            deviceSvg.push(`<rect x="${bg.x}" y="${bg.y}" width="${bg.width}" height="${bg.height}" fill="#555" stroke="none"/>`);
            const circle1 = device_symbols_1.DeviceSymbols.getTapeDriveCircle1();
            const circle2 = device_symbols_1.DeviceSymbols.getTapeDriveCircle2();
            deviceSvg.push(`<circle cx="${circle1.cx}" cy="${circle1.cy}" r="${circle1.r}" stroke="#ccc" fill="#555" stroke-width="2"/>`);
            deviceSvg.push(`<circle cx="${circle2.cx}" cy="${circle2.cy}" r="${circle2.r}" stroke="#ccc" fill="#555" stroke-width="2"/>`);
            break;
          case "ups":
            const upsPath = device_symbols_1.DeviceSymbols.getSymbolPath("ups");
            deviceSvg.push(`<path d="${upsPath}" fill="#555" stroke="none"/>`);
            break;
          default:
            const symbolPath = device_symbols_1.DeviceSymbols.getSymbolPath(device.type);
            if (symbolPath) {
              deviceSvg.push(`<path d="${symbolPath}" fill="none" stroke="#555" stroke-width="2"/>`);
            }
            break;
        }
      }
      // Scale for height units (U) to the left of the rack
      generateRackScale(rackHeight) {
        const sb = [];
        const scaleX = 44;
        const textX = scaleX;
        const lineX1 = scaleX - 14;
        const lineX2 = scaleX + 2;
        for (let u = rackHeight; u >= 1; u--) {
          const y = SvgGenerator.DEFAULT_SVG_MARGIN + (rackHeight - u) * SvgGenerator.DEFAULT_RACK_UNIT_POINTS;
          sb.push(`<text x="${textX}" y="${y + SvgGenerator.DEFAULT_RACK_UNIT_POINTS / 2 + 2}" text-anchor="end" dominant-baseline="middle" font-family="sans-serif" font-size="12">${u}</text>`);
          sb.push(`<line x1="${lineX1}" y1="${y}" x2="${lineX2}" y2="${y}" stroke="black" stroke-width="2"/>`);
        }
        const yBottom = SvgGenerator.DEFAULT_SVG_MARGIN + rackHeight * SvgGenerator.DEFAULT_RACK_UNIT_POINTS;
        sb.push(`<line x1="${lineX1}" y1="${yBottom}" x2="${lineX2}" y2="${yBottom}" stroke="black" stroke-width="2"/>`);
        return sb.join("\n");
      }
      xmlEscape(input) {
        return input.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#39;");
      }
      isAbsoluteUrl(url) {
        try {
          new URL(url);
          return true;
        } catch (e) {
          return false;
        }
      }
      calculateActualRackHeight(rack) {
        let maxHeight = rack.height;
        let currentPosition = 0;
        for (const device of rack.devices) {
          const at = device.position !== void 0 ? device.position - 1 : currentPosition;
          const deviceEndPosition = at + device.height;
          if (deviceEndPosition > maxHeight) {
            maxHeight = deviceEndPosition;
          }
          currentPosition = at + device.height;
        }
        return maxHeight;
      }
    };
    exports.SvgGenerator = SvgGenerator;
    SvgGenerator.DEFAULT_RACK_HEIGHT_UNITS = 42;
    SvgGenerator.DEFAULT_RACK_SPACING_POINTS = 25;
    SvgGenerator.DEFAULT_RACK_UNIT_POINTS = 25;
    SvgGenerator.DEFAULT_RACK_WIDTH_POINTS = 300;
    SvgGenerator.DEFAULT_SVG_MARGIN = 25;
  }
});

// node_modules/@aurora/rack-visualization-js/dist/index.js
var require_dist = __commonJS({
  "node_modules/@aurora/rack-visualization-js/dist/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RackVisualization = exports.DeviceSymbols = exports.ColorSchemes = exports.SvgGenerator = exports.TextMarkupParser = exports.RackMLParser = void 0;
    __exportStar(require_models(), exports);
    var rackml_parser_1 = require_rackml_parser();
    Object.defineProperty(exports, "RackMLParser", { enumerable: true, get: function() {
      return rackml_parser_1.RackMLParser;
    } });
    var text_markup_parser_1 = require_text_markup_parser();
    Object.defineProperty(exports, "TextMarkupParser", { enumerable: true, get: function() {
      return text_markup_parser_1.TextMarkupParser;
    } });
    var svg_generator_1 = require_svg_generator();
    Object.defineProperty(exports, "SvgGenerator", { enumerable: true, get: function() {
      return svg_generator_1.SvgGenerator;
    } });
    var color_schemes_1 = require_color_schemes();
    Object.defineProperty(exports, "ColorSchemes", { enumerable: true, get: function() {
      return color_schemes_1.ColorSchemes;
    } });
    var device_symbols_1 = require_device_symbols();
    Object.defineProperty(exports, "DeviceSymbols", { enumerable: true, get: function() {
      return device_symbols_1.DeviceSymbols;
    } });
    var rackml_parser_2 = require_rackml_parser();
    var text_markup_parser_2 = require_text_markup_parser();
    var svg_generator_2 = require_svg_generator();
    var RackVisualization2 = class {
      constructor() {
        this.svgGenerator = new svg_generator_2.SvgGenerator();
      }
      /**
       * Parse RackML XML and generate SVG
       */
      parseRackMLAndGenerateSvg(rackmlContent) {
        const rackSet = rackml_parser_2.RackMLParser.parseRackML(rackmlContent);
        return this.svgGenerator.generateSvg(rackSet);
      }
      /**
       * Parse text markup and generate SVG
       */
      parseTextMarkupAndGenerateSvg(textContent) {
        const parser = new text_markup_parser_2.TextMarkupParser(textContent);
        const rackSet = parser.parse();
        return this.svgGenerator.generateSvg(rackSet);
      }
      /**
       * Generate SVG from RackSet
       */
      generateSvg(rackSet) {
        return this.svgGenerator.generateSvg(rackSet);
      }
    };
    exports.RackVisualization = RackVisualization2;
  }
});

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => RackVisualizationPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var import_rack_visualization_js = __toESM(require_dist());
var RackVisualizationPlugin = class extends import_obsidian.Plugin {
  async onload() {
    console.log("Loading Rack Visualization Plugin");
    this.registerMarkdownCodeBlockProcessor("rack-xml", (source, el, ctx) => {
      this.processRackXml(source, el, ctx);
    });
    this.registerMarkdownCodeBlockProcessor("rack-text", (source, el, ctx) => {
      this.processRackText(source, el, ctx);
    });
    this.registerMarkdownCodeBlockProcessor("rackml", (source, el, ctx) => {
      this.processRackXml(source, el, ctx);
    });
    this.registerMarkdownCodeBlockProcessor("rack", (source, el, ctx) => {
      this.processRackText(source, el, ctx);
    });
  }
  onunload() {
    console.log("Unloading Rack Visualization Plugin");
  }
  async processRackXml(source, el, ctx) {
    try {
      const rackViz = new import_rack_visualization_js.RackVisualization();
      const svgContent = rackViz.parseRackMLAndGenerateSvg(source.trim());
      const rackSet = import_rack_visualization_js.RackMLParser.parseRackML(source.trim());
      this.convertObsidianLinks(rackSet, ctx);
      const finalSvgContent = rackViz.generateSvg(rackSet);
      const svgPath = await this.saveSvgToAssets(finalSvgContent, rackSet, ctx);
      this.insertSvg(el, finalSvgContent, svgPath, rackSet);
    } catch (error) {
      this.showError(el, `Error parsing RackML XML: ${error.message}`);
    }
  }
  async processRackText(source, el, ctx) {
    try {
      const rackViz = new import_rack_visualization_js.RackVisualization();
      const svgContent = rackViz.parseTextMarkupAndGenerateSvg(source.trim());
      const parser = new import_rack_visualization_js.TextMarkupParser(source.trim());
      const rackSet = parser.parse();
      this.convertObsidianLinks(rackSet, ctx);
      const finalSvgContent = rackViz.generateSvg(rackSet);
      const svgPath = await this.saveSvgToAssets(finalSvgContent, rackSet, ctx);
      this.insertSvg(el, finalSvgContent, svgPath, rackSet);
    } catch (error) {
      this.showError(el, `Error parsing rack text markup: ${error.message}`);
    }
  }
  convertObsidianLinks(rackSet, ctx) {
    for (const rack of rackSet.racks) {
      for (const device of rack.devices) {
        if (device.href) {
          device.href = this.resolveObsidianLink(device.href, ctx);
        }
        if (device.name) {
          const linkMatch = device.name.match(/\[\[([^\]]+)\]\]/);
          if (linkMatch) {
            const linkText = linkMatch[1];
            const resolvedLink = this.resolveObsidianLink(linkText, ctx);
            device.name = device.name.replace(linkMatch[0], linkText);
            device.href = resolvedLink;
          }
        }
      }
    }
  }
  resolveObsidianLink(link, ctx) {
    if (link.startsWith("[[") && link.endsWith("]]")) {
      const noteName = link.slice(2, -2);
      return `obsidian://open?vault=${encodeURIComponent(this.app.vault.getName())}&file=${encodeURIComponent(noteName)}`;
    }
    if (!link.startsWith("http://") && !link.startsWith("https://") && !link.startsWith("obsidian://")) {
      return `obsidian://open?vault=${encodeURIComponent(this.app.vault.getName())}&file=${encodeURIComponent(link)}`;
    }
    return link;
  }
  insertSvg(el, svgContent, svgPath, rackSet) {
    el.innerHTML = "";
    const container = document.createElement("div");
    container.className = "rack-visualization-container";
    container.style.textAlign = "center";
    container.style.margin = "1em 0";
    container.innerHTML = svgContent;
    const svg = container.querySelector("svg");
    if (svg) {
      svg.style.maxWidth = "100%";
      svg.style.height = "auto";
    }
    if (svgPath) {
      const note = document.createElement("div");
      note.className = "rack-visualization-note";
      note.style.fontSize = "0.8em";
      note.style.color = "#666";
      note.style.marginTop = "0.5em";
      note.textContent = `SVG gespeichert: ${svgPath}`;
      container.appendChild(note);
      if (rackSet && (!rackSet.id || !rackSet.id.trim())) {
        const tip = document.createElement("div");
        tip.className = "rack-visualization-tip";
        tip.style.fontSize = "0.75em";
        tip.style.color = "#888";
        tip.style.fontStyle = "italic";
        tip.style.marginTop = "0.25em";
        tip.textContent = `\u{1F4A1} Tipp: F\xFCgen Sie 'id: mein-name' hinzu f\xFCr konsistente Dateinamen`;
        container.appendChild(tip);
      }
    }
    el.appendChild(container);
  }
  showError(el, message) {
    el.innerHTML = "";
    const errorDiv = document.createElement("div");
    errorDiv.className = "rack-visualization-error";
    errorDiv.style.color = "red";
    errorDiv.style.border = "1px solid red";
    errorDiv.style.padding = "1em";
    errorDiv.style.borderRadius = "4px";
    errorDiv.style.backgroundColor = "#ffe6e6";
    errorDiv.textContent = message;
    el.appendChild(errorDiv);
  }
  async saveSvgToAssets(svgContent, rackSet, ctx) {
    var _a;
    try {
      const currentFile = this.app.workspace.getActiveFile();
      if (!currentFile) {
        console.warn("No active file found, cannot save SVG to assets folder");
        return void 0;
      }
      const filename = this.generateSvgFilename(rackSet, ctx);
      const currentDir = ((_a = currentFile.parent) == null ? void 0 : _a.path) || "";
      const assetsDir = currentDir ? `${currentDir}/assets` : "assets";
      if (!await this.app.vault.adapter.exists(assetsDir)) {
        await this.app.vault.adapter.mkdir(assetsDir);
      }
      const svgPath = `${assetsDir}/${filename}`;
      await this.app.vault.adapter.write(svgPath, svgContent);
      console.log(`SVG saved to: ${svgPath}`);
      return svgPath;
    } catch (error) {
      console.error("Error saving SVG to assets folder:", error);
      return void 0;
    }
  }
  generateSvgFilename(rackSet, ctx) {
    const currentFile = this.app.workspace.getActiveFile();
    const documentName = currentFile ? currentFile.basename : "document";
    const cleanDocumentName = documentName.toLowerCase().replace(/[^a-z0-9\-_]/g, "-").replace(/-+/g, "-").replace(/^-|-$/g, "");
    if (rackSet.id && rackSet.id.trim()) {
      const cleanId = rackSet.id.trim().toLowerCase().replace(/[^a-z0-9\-_]/g, "-").replace(/-+/g, "-").replace(/^-|-$/g, "");
      return `${cleanDocumentName}-${cleanId}.svg`;
    }
    let baseName = "rack-diagram";
    if (rackSet.racks.length > 0) {
      const firstRack = rackSet.racks[0];
      if (firstRack.name && firstRack.name.trim()) {
        baseName = firstRack.name.trim().toLowerCase().replace(/[^a-z0-9\-_]/g, "-").replace(/-+/g, "-").replace(/^-|-$/g, "");
      }
      if (rackSet.racks.length > 1) {
        baseName += `-${rackSet.racks.length}racks`;
      }
    }
    return `${cleanDocumentName}-${baseName}.svg`;
  }
};
